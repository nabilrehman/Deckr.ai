

import { GoogleGenAI, Modality } from "@google/genai";

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

export interface BoundingBox {
  x: number;
  y: number;
  width: number;
  height: number;
}

export interface TextReplacement {
    originalText: string;
    newText: string;
}

const fileToGenerativePart = (base64Data: string) => {
    const match = base64Data.match(/^data:(image\/\w+);base64,(.*)$/);
    if (!match) {
        throw new Error("Invalid base64 image data string.");
    }
    const mimeType = match[1];
    const data = match[2];

    return {
        inlineData: {
            data,
            mimeType,
        },
    };
};

const createMaskFromSelection = async (
    selection: { x: number; y: number; width: number; height: number; naturalWidth: number; naturalHeight: number }
): Promise<string> => {
    const canvas = document.createElement('canvas');
    canvas.width = selection.naturalWidth;
    canvas.height = selection.naturalHeight;
    const ctx = canvas.getContext('2d');

    if (!ctx) {
        throw new Error("Could not create canvas context for mask.");
    }

    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = 'white';
    ctx.fillRect(selection.x, selection.y, selection.width, selection.height);

    return canvas.toDataURL('image/png');
};

const generateSingleImage = async (model: string, parts: any[], config: any): Promise<string> => {
    const response = await ai.models.generateContent({ model, contents: { parts }, config });
    const candidate = response.candidates?.[0];

    if (!candidate || !candidate.content?.parts || candidate.content.parts.length === 0) {
        const finishReason = candidate?.finishReason;
        if (finishReason === 'SAFETY') {
            throw new Error("Generation failed due to safety settings.");
        }
        if (finishReason === 'RECITATION') {
            throw new Error("Generation failed due to recitation policy.");
        }
        throw new Error(`No image was generated by the AI. (Reason: ${finishReason || 'Unknown'})`);
    }

    for (const part of candidate.content.parts) {
        if (part.inlineData) {
            const base64ImageBytes = part.inlineData.data;
            const mimeType = part.inlineData.mimeType;
            return `data:${mimeType};base64,${base64ImageBytes}`;
        }
    }
    
    throw new Error("No image data found in the AI's response.");
};

export const editImage = async (base64Image: string, prompt: string): Promise<string> => {
    const imagePart = fileToGenerativePart(base64Image);
    const textPart = { text: prompt };
    return generateSingleImage('gemini-2.5-flash-image', [imagePart, textPart], { responseModalities: [Modality.IMAGE] });
};

export const inpaintImage = async (
    base64Image: string,
    selection: { x: number; y: number; width: number; height: number; naturalWidth: number; naturalHeight: number },
    prompt: string
): Promise<string> => {
    const maskBase64 = await createMaskFromSelection(selection);
    const imagePart = fileToGenerativePart(base64Image);
    const maskPart = fileToGenerativePart(maskBase64);
    const inpaintPrompt = `You are an expert image editor performing an inpainting task. You are given three inputs:
1. An original image.
2. A mask image (black with a white area).
3. A text prompt describing a change.
Your task is to edit the original image **only** within the area defined by the white region of the mask. You MUST preserve the rest of the original image perfectly.
The edit to perform within the masked area is: "${prompt}"`;
    const textPart = { text: inpaintPrompt };
    return generateSingleImage('gemini-2.5-flash-image', [imagePart, maskPart, textPart], { responseModalities: [Modality.IMAGE] });
};


export const compositeImage = async (baseImage: string, overlayImage: string, prompt: string): Promise<string> => {
    const baseImagePart = fileToGenerativePart(baseImage);
    const overlayImagePart = fileToGenerativePart(overlayImage);
    const compositePrompt = `Perfectly preserve the first image (the slide). Place the second image (the logo) on top of the first image according to these instructions: ${prompt}. Do not change the slide content, colors, or layout. It's critical that the original slide is preserved.`;
    const textPart = { text: compositePrompt };
    return generateSingleImage('gemini-2.5-flash-image', [baseImagePart, overlayImagePart, textPart], { responseModalities: [Modality.IMAGE] });
};

// AGENT 1: The Business Strategist
const generatePersonalizedContent = async (companyWebsite: string, base64Image: string): Promise<TextReplacement[]> => {
    const systemPrompt = `You are a world-class "Business Strategist" AI. Your task is to analyze a slide image and a company website to generate a list of text replacements that will make the slide highly relevant to that company.
1.  **Analyze the slide image:** Use your vision to read and understand the content and structure of the provided slide.
2.  **Research the company:** Use Google Search with the provided website URL (\`${companyWebsite}\`) to understand the company's core business, products, services, and terminology.
3.  **Generate Replacements:** Identify key phrases or generic terms on the slide that can be replaced with company-specific content. Create a list of replacements. The "originalText" MUST match text on the slide exactly.
4.  **Output:** Return a valid JSON array of objects with the schema \`{ "originalText": "text to find on slide", "newText": "new company-specific text" }\`.`;
    
    const imagePart = fileToGenerativePart(base64Image);
    const textPart = { text: systemPrompt };

    const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: { parts: [imagePart, textPart] },
        config: { tools: [{ googleSearch: {} }] }
    });
    
    const jsonText = response.text.trim().replace(/^```json\s*|```\s*$/g, '');
    try {
        return JSON.parse(jsonText);
    } catch (e) {
        console.error("Failed to parse personalized content from AI:", e, jsonText);
        throw new Error("The AI strategist failed to generate a valid content plan.");
    }
};

// Main Orchestrator for the "Personalize" feature
export const getPersonalizedVariations = async (companyWebsite: string, base64Image: string): Promise<string[]> => {
    const replacements = await generatePersonalizedContent(companyWebsite, base64Image);

    if (!replacements || replacements.length === 0) {
        throw new Error("The AI strategist could not find any content to personalize on this slide.");
    }

    const replacementInstructions = replacements.map(r => `- Replace the text "${r.originalText}" with "${r.newText}"`).join('\n');
    const artistPrompt = `You are a "High-Fidelity Artist". Your task is to edit the provided slide image by replacing specific text.
**Instructions:**
1.  Carefully find and replace the following text on the slide:
${replacementInstructions}
2.  **CRITICAL:** The new text must perfectly match the font, color, size, position, and style of the text it is replacing.
3.  **DO NOT** change any other part of the slide. The layout, other text, and images must be preserved with 100% accuracy.`;

    const variationPrompts = [
        artistPrompt,
        `${artistPrompt}\n(For this version, try a slightly more creative or visually distinct style for the new text if possible, while still matching the slide's overall theme.)`,
        `${artistPrompt}\n(For this version, offer another alternative that is clean and professional.)`,
    ];

    const results: string[] = [];
    for (const p of variationPrompts) {
        results.push(await editImage(base64Image, p));
    }
    
    return results;
};

// The simple, single-step generative function that relies on the AI's vision.
export const getGenerativeVariations = async (prompt: string, base64Image: string): Promise<string[]> => {
    const systemPrompt = `You are a world-class AI agent acting as a "Design Analyst". Your job is to analyze a slide image and a user's request to create a perfect, actionable prompt for a generative image model.

**Your Process:**
1.  **Analyze the Image:** The provided slide image is your ONLY source of truth. Use your vision to perform OCR and understand the slide's content, layout, and style.
2.  **Analyze the User's Request:** Understand the user's core intent.
3.  **Construct a High-Fidelity Prompt:** Create an expertly crafted, high-fidelity prompt for the image model. This prompt must describe the **FINAL DESIRED STATE**. Do not give sequential instructions like "First do X, then do Y."
    *   **Fidelity is Paramount**: Your prompt MUST include this non-negotiable rule: **"It is absolutely critical to preserve all original branding (logos), text, fonts, colors, and specific numbering with 100% accuracy. The final image must be a perfect match in style to the original, with only the requested change applied."**
    *   **For List Manipulation (Add, Remove, Renumber):** Analyze the list in the image. Determine the final, correct state of the list's content and numbering. Your prompt must explicitly describe this final state (e.g., "Recreate this slide to contain only three numbered items: '01 ...', '02 ...', '03 ...'").
---
**User's Request:** "${prompt}"`;
        
    const imagePart = fileToGenerativePart(base64Image);
    const textPart = { text: systemPrompt };

    const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: { parts: [imagePart, textPart] },
    });
    
    const refinedPrompt = response.text.trim();
    if (!refinedPrompt) {
        throw new Error("The AI Analyst failed to generate a refined prompt.");
    }
    
     const variationPrompts = [
        refinedPrompt,
        `${refinedPrompt} (Try a slightly different, creative style.)`,
        `${refinedPrompt} (Offer another alternative version.)`,
    ];

    const results: string[] = [];
    for (const p of variationPrompts) {
        results.push(await editImage(base64Image, p));
    }
    
    return results;
};