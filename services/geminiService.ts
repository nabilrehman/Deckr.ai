

import { GoogleGenAI, Modality } from "@google/genai";

// Fix: Initialize GoogleGenAI directly with the environment variable as per guidelines.
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

const fileToGenerativePart = (base64Data: string) => {
    const match = base64Data.match(/^data:(image\/\w+);base64,(.*)$/);
    if (!match) {
        throw new Error("Invalid base64 image data string.");
    }
    const mimeType = match[1];
    const data = match[2];

    return {
        inlineData: {
            data,
            mimeType,
        },
    };
};

export const editImage = async (base64Image: string, prompt: string): Promise<string> => {
    try {
        const imagePart = fileToGenerativePart(base64Image);
        const textPart = { text: prompt };

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: [imagePart, textPart],
            },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        const candidate = response.candidates?.[0];

        if (!candidate || !candidate.content?.parts || candidate.content.parts.length === 0) {
            const finishReason = candidate?.finishReason;
            if (finishReason === 'SAFETY') {
                throw new Error("Generation failed due to safety settings. Prompts involving brands or logos may be restricted.");
            }
            if (finishReason === 'RECITATION') {
                throw new Error("Generation failed due to recitation policy. The model detected copyrighted content.");
            }
            throw new Error(`No image was generated by the AI. (Reason: ${finishReason || 'Unknown'})`);
        }

        for (const part of candidate.content.parts) {
            if (part.inlineData) {
                const base64ImageBytes = part.inlineData.data;
                const mimeType = part.inlineData.mimeType;
                return `data:${mimeType};base64,${base64ImageBytes}`;
            }
        }
        
        throw new Error("No image data found in the AI's response.");
    } catch (error: any) {
        console.error("Error editing image with Gemini:", error);
        if (error.message && (error.message.includes('API key not valid') || error.message.includes('API_KEY_INVALID'))) {
            throw new Error("Invalid API Key. Please ensure your API key is correctly configured in the environment secrets.");
        }
        // Re-throw custom, user-friendly errors we created above
        if (error.message.startsWith("Generation failed") || error.message.startsWith("No image was generated")) {
            throw error;
        }
        throw new Error("Failed to generate image. Please check the console for more details.");
    }
};

export const compositeImage = async (baseImage: string, overlayImage: string, prompt: string): Promise<string> => {
    try {
        const baseImagePart = fileToGenerativePart(baseImage);
        const overlayImagePart = fileToGenerativePart(overlayImage);
        // A more directive prompt for composition
        const fullPrompt = `Perfectly preserve the first image (the slide). Place the second image (the logo) on top of the first image according to these instructions: ${prompt}. Do not change the slide content, colors, or layout. Your jobs is just to retain 100% of origninal image layout, styling, fonts, text styling etc. Please this is very important for you`;
        const textPart = { text: fullPrompt };

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: [baseImagePart, overlayImagePart, textPart],
            },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        const candidate = response.candidates?.[0];

        if (!candidate || !candidate.content?.parts || candidate.content.parts.length === 0) {
            const finishReason = candidate?.finishReason;
            if (finishReason === 'SAFETY') {
                throw new Error("Generation failed due to safety settings.");
            }
            if (finishReason === 'RECITATION') {
                throw new Error("Generation failed due to recitation policy.");
            }
            throw new Error(`No image was generated by the AI. (Reason: ${finishReason || 'Unknown'})`);
        }

        for (const part of candidate.content.parts) {
            if (part.inlineData) {
                const base64ImageBytes = part.inlineData.data;
                const mimeType = part.inlineData.mimeType;
                return `data:${mimeType};base64,${base64ImageBytes}`;
            }
        }
        
        throw new Error("No image data found in the AI's response.");
    } catch (error: any) {
        console.error("Error compositing image with Gemini:", error);
        if (error.message && (error.message.includes('API key not valid') || error.message.includes('API_KEY_INVALID'))) {
            throw new Error("Invalid API Key. Please ensure your API key is correctly configured in the environment secrets.");
        }
        if (error.message.startsWith("Generation failed") || error.message.startsWith("No image was generated")) {
            throw error;
        }
        throw new Error("Failed to place image. Please check the console for more details.");
    }
};

export const researchAndRefinePrompt = async (prompt: string): Promise<{ refinedPrompt: string; sources: any[] }> => {
    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: `You are an expert prompt engineer for a generative AI image model. Your task is to rewrite a user's request into a more effective prompt.

Here's your process:
1.  **Analyze the User's Request**: Identify the user's core intent (e.g., "add a logo", "place it on the top right").
2.  **Conduct Research (if necessary)**: If the request involves a specific real-world entity like a company logo (e.g., "Tripadvisor logo"), you MUST use Google Search to find the official version.
3.  **Perform Detailed Visual Analysis**: Meticulously analyze the visual details of the subject. For a logo, this includes:
    *   **Icon/Symbol**: Describe any graphical elements, including shapes and specific colors for each part (e.g., for Tripadvisor's owl, "the left eye is red, the right eye is green").
    *   **Wordmark/Typography**: Describe the text, casing, font style, and any color variations within the text (e.g., "the word 'trip' is black, and 'advisor' is green").
    *   **Color Palette**: List all primary colors.
    *   **Composition**: Describe the arrangement of the icon and wordmark.
    *   **Overall Style**: Describe the aesthetic (e.g., "flat, 2D, minimalist").
4.  **Construct the Final Prompt**: Combine the user's original intent with your detailed visual analysis. The final prompt MUST be a clear, direct instruction to the image model. Crucially, it must begin with a strong directive to preserve the original image, such as "Preserve the original image perfectly." Follow this with the user's action and location, and then the detailed description.

**Example:**
*   **User's Request**: "can you please add logo of tripadvisor.com and add it on top right"
*   **Your Final Prompt Output**: "Preserve the original image perfectly. Add the Tripadvisor logo to the top right of the image. The logo consists of an owl icon above a wordmark. The owl has two large circular eyes, where the left eye is red and the right eye is green, set against a beige background patch. The wordmark says 'Tripadvisor' in a lowercase, rounded sans-serif font. The word 'trip' is black, and the word 'advisor' is a vibrant green. The entire logo is flat, 2D, and minimalist."

Now, process the user's request below. Output ONLY the final, rewritten prompt for the image model.

User's request: "${prompt}"`,
            config: {
                tools: [{googleSearch: {}}],
            },
        });

        const refinedPrompt = response.text;
        const sources = response.candidates?.[0]?.groundingMetadata?.groundingChunks || [];
        
        // If the refined prompt is empty or just whitespace, fall back to the original prompt
        if (!refinedPrompt || !refinedPrompt.trim()) {
            console.warn("Prompt refinement resulted in an empty string. Falling back to original prompt.");
            return { refinedPrompt: prompt, sources: [] };
        }

        return { refinedPrompt, sources };
    } catch (error) {
        console.error("Error refining prompt with Gemini:", error);
        // Fallback to original prompt on error for a seamless user experience
        return { refinedPrompt: prompt, sources: [] };
    }
};